/**
 * æ ·å¼ä¿®å¤å¼•æ“ - è§£å†³DOCXåˆ°HTMLè½¬æ¢ä¸­æ ·å¼ä¸¢å¤±çš„é—®é¢˜
 *
 * ä¸»è¦é—®é¢˜åˆ†æï¼š
 * 1. mammothçš„æ ·å¼æ˜ å°„é…ç½®ä¸å®Œæ•´
 * 2. æ ·å¼æå–å™¨æ²¡æœ‰æ­£ç¡®ç”ŸæˆCSS
 * 3. æ ·å¼æ³¨å…¥æ—¶æœºä¸å¯¹
 * 4. CSSé€‰æ‹©å™¨ä¼˜å…ˆçº§ä¸å¤Ÿ
 */

const mammoth = require('mammoth');
const fs = require('fs').promises;
const JSZip = require('jszip');
const xml2js = require('xml2js');
const cheerio = require('cheerio');

interface StyleFixOptions {
  preserveImages?: boolean;
  enableDebug?: boolean;
  forceWordStyles?: boolean;
  customFontFamily?: string;
}

interface FixedConversionResult {
  success: boolean;
  content?: string;
  error?: string;
  metadata?: {
    stylesExtracted: number;
    cssRulesGenerated: number;
    elementsStyled: number;
    converter: string;
  };
}

export class StyleFixEngine {
  private docxStyles: Map<string, any> = new Map();
  private cssRules: string[] = [];
  private options: StyleFixOptions;

  constructor(options: StyleFixOptions = {}) {
    this.options = {
      preserveImages: true,
      enableDebug: false,
      forceWordStyles: true,
      customFontFamily: 'Microsoft YaHei',
      ...options,
    };
  }

  /**
   * ä¸»è¦ä¿®å¤å‡½æ•° - è§£å†³æ ·å¼ä¸¢å¤±é—®é¢˜
   */
  async fixDocxToHtml(docxPath: string): Promise<FixedConversionResult> {
    try {
      this.log('ğŸ”§ å¼€å§‹æ ·å¼ä¿®å¤è½¬æ¢...');

      // æ­¥éª¤1: æå–DOCXä¸­çš„åŸå§‹æ ·å¼ä¿¡æ¯
      await this.extractDocxStyles(docxPath);

      // æ­¥éª¤2: ä½¿ç”¨ä¿®å¤åçš„mammothé…ç½®è¿›è¡Œè½¬æ¢
      const mammothResult = await this.convertWithFixedMammoth(docxPath);

      // æ­¥éª¤3: å¼ºåˆ¶æ³¨å…¥Wordæ ·å¼
      const styledHtml = this.injectWordStyles(mammothResult.value);

      // æ­¥éª¤4: éªŒè¯å’Œä¼˜åŒ–æœ€ç»ˆHTML
      const finalHtml = this.optimizeFinalHtml(styledHtml);

      this.log('âœ… æ ·å¼ä¿®å¤å®Œæˆ');

      return {
        success: true,
        content: finalHtml,
        metadata: {
          stylesExtracted: this.docxStyles.size,
          cssRulesGenerated: this.cssRules.length,
          elementsStyled: this.countStyledElements(finalHtml),
          converter: 'style-fix-engine',
        },
      };
    } catch (error: any) {
      this.log('âŒ æ ·å¼ä¿®å¤å¤±è´¥:', error.message);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * æå–DOCXä¸­çš„æ ·å¼ä¿¡æ¯
   */
  private async extractDocxStyles(docxPath: string): Promise<void> {
    this.log('ğŸ“Š æå–DOCXæ ·å¼ä¿¡æ¯...');

    const docxBuffer = await fs.readFile(docxPath);
    const zip = await JSZip.loadAsync(docxBuffer);

    // æå–styles.xml
    const stylesFile = zip.file('word/styles.xml');
    if (stylesFile) {
      const stylesXml = await stylesFile.async('text');
      const stylesData = await xml2js.parseStringPromise(stylesXml, {
        explicitArray: false,
        mergeAttrs: true,
      });

      if (stylesData['w:styles'] && stylesData['w:styles']['w:style']) {
        const styles = Array.isArray(stylesData['w:styles']['w:style'])
          ? stylesData['w:styles']['w:style']
          : [stylesData['w:styles']['w:style']];

        for (const style of styles) {
          const styleId = style.styleId || style['w:styleId'];
          if (styleId) {
            this.docxStyles.set(styleId, style);
            this.log(`  å‘ç°æ ·å¼: ${styleId}`);
          }
        }
      }
    }

    this.log(`ğŸ“Š æå–äº† ${this.docxStyles.size} ä¸ªæ ·å¼å®šä¹‰`);
  }

  /**
   * ä½¿ç”¨ä¿®å¤åçš„mammothé…ç½®è¿›è¡Œè½¬æ¢
   */
  private async convertWithFixedMammoth(docxPath: string): Promise<any> {
    this.log('ğŸ”„ ä½¿ç”¨ä¿®å¤åçš„mammothé…ç½®è½¬æ¢...');

    // åˆ›å»ºå¼ºåŒ–çš„æ ·å¼æ˜ å°„
    const styleMap = this.createEnhancedStyleMap();

    const config = {
      styleMap: styleMap,

      // å›¾ç‰‡å¤„ç†
      convertImage: this.options.preserveImages
        ? mammoth.images.imgElement((image: any) => {
            return image.read('base64').then((imageBuffer: string) => {
              return {
                src: `data:${image.contentType};base64,${imageBuffer}`,
                alt: image.altText || 'Document Image',
              };
            });
          })
        : mammoth.images.ignore,

      // åŒ…å«é»˜è®¤æ ·å¼æ˜ å°„
      includeDefaultStyleMap: true,

      // åŒ…å«åµŒå…¥æ ·å¼
      includeEmbeddedStyleMap: true,

      // ä¸å¿½ç•¥ç©ºæ®µè½
      ignoreEmptyParagraphs: false,

      // è½¬æ¢æ–‡æ¡£æ—¶ä¿ç•™æ›´å¤šä¿¡æ¯
      transformDocument: mammoth.transforms.paragraph((element: any) => {
        // ä¸ºæ¯ä¸ªæ®µè½æ·»åŠ æ ·å¼ç±»
        if (element.styleName) {
          return {
            ...element,
            styleId: element.styleName,
            className: this.sanitizeClassName(element.styleName),
          };
        }
        return element;
      }),
    };

    const result = await mammoth.convertToHtml({ path: docxPath }, config);

    this.log('ğŸ“„ mammothè½¬æ¢ç»“æœ:');
    this.log(`  - å†…å®¹é•¿åº¦: ${result.value.length}`);
    this.log(`  - æ¶ˆæ¯æ•°é‡: ${result.messages.length}`);

    return result;
  }

  /**
   * åˆ›å»ºå¢å¼ºçš„æ ·å¼æ˜ å°„
   */
  private createEnhancedStyleMap(): string[] {
    const styleMap = [
      // åŸºç¡€æ®µè½æ ·å¼ - ä¿ç•™æ ·å¼ä¿¡æ¯
      "p[style-name='Normal'] => p.normal:fresh",
      "p[style-name='æ­£æ–‡'] => p.normal:fresh",
      "p[style-name='Body Text'] => p.body-text:fresh",

      // æ ‡é¢˜æ ·å¼ - ä¿ç•™å±‚çº§å’Œæ ·å¼
      "p[style-name='Heading 1'] => h1.heading-1:fresh",
      "p[style-name='æ ‡é¢˜ 1'] => h1.heading-1:fresh",
      "p[style-name='Heading 2'] => h2.heading-2:fresh",
      "p[style-name='æ ‡é¢˜ 2'] => h2.heading-2:fresh",
      "p[style-name='Heading 3'] => h3.heading-3:fresh",
      "p[style-name='æ ‡é¢˜ 3'] => h3.heading-3:fresh",
      "p[style-name='Heading 4'] => h4.heading-4:fresh",
      "p[style-name='æ ‡é¢˜ 4'] => h4.heading-4:fresh",
      "p[style-name='Heading 5'] => h5.heading-5:fresh",
      "p[style-name='æ ‡é¢˜ 5'] => h5.heading-5:fresh",
      "p[style-name='Heading 6'] => h6.heading-6:fresh",
      "p[style-name='æ ‡é¢˜ 6'] => h6.heading-6:fresh",

      // ç‰¹æ®Šæ ·å¼
      "p[style-name='Title'] => h1.title:fresh",
      "p[style-name='Subtitle'] => h2.subtitle:fresh",
      "p[style-name='æ ‡é¢˜'] => h1.title:fresh",
      "p[style-name='å‰¯æ ‡é¢˜'] => h2.subtitle:fresh",

      // å­—ç¬¦æ ·å¼ - ä¿ç•™æ ¼å¼
      "r[style-name='Strong'] => strong.word-strong",
      "r[style-name='Emphasis'] => em.word-emphasis",
      "r[style-name='åŠ ç²—'] => strong.word-strong",
      "r[style-name='æ–œä½“'] => em.word-emphasis",

      // åˆ—è¡¨æ ·å¼
      "p[style-name='List Paragraph'] => li.list-item:fresh",
      "p[style-name='åˆ—è¡¨æ®µè½'] => li.list-item:fresh",
      "p[style-name='Bullet List'] => li.bullet-item:fresh",
      "p[style-name='Numbered List'] => li.numbered-item:fresh",

      // è¡¨æ ¼æ ·å¼
      'table => table.docx-table',
      'tr => tr.docx-row',
      'td => td.docx-cell',
      'th => th.docx-header',

      // é€šç”¨æ˜ å°„ - ä¿ç•™æ‰€æœ‰æ ·å¼ä¿¡æ¯
      'p => p.docx-paragraph:fresh',
      'r => span.docx-run',
      'b => strong.docx-bold',
      'i => em.docx-italic',
      'u => span.docx-underline',
      'strike => span.docx-strikethrough',
      'sup => sup.docx-superscript',
      'sub => sub.docx-subscript',
    ];

    // ä¸ºæ¯ä¸ªæå–çš„æ ·å¼åˆ›å»ºæ˜ å°„
    for (const [styleId, styleData] of this.docxStyles) {
      const className = this.sanitizeClassName(styleId);
      const styleName = styleData['w:name']?.[0]?.val || styleId;

      if (styleData.type === 'paragraph') {
        styleMap.push(`p[style-name='${styleName}'] => p.${className}:fresh`);
      } else if (styleData.type === 'character') {
        styleMap.push(`r[style-name='${styleName}'] => span.${className}`);
      }
    }

    this.log(`ğŸ“‹ åˆ›å»ºäº† ${styleMap.length} ä¸ªæ ·å¼æ˜ å°„`);
    return styleMap;
  }

  /**
   * å¼ºåˆ¶æ³¨å…¥Wordæ ·å¼
   */
  private injectWordStyles(html: string): string {
    this.log('ğŸ’‰ æ³¨å…¥Wordæ ·å¼...');

    // ç”Ÿæˆå®Œæ•´çš„Wordæ ·å¼CSS
    const wordStyles = this.generateWordStylesCSS();

    // å¦‚æœHTMLå·²ç»æœ‰å®Œæ•´ç»“æ„ï¼Œåœ¨headä¸­æ³¨å…¥æ ·å¼
    if (html.includes('<html>') || html.includes('<!DOCTYPE')) {
      if (html.includes('</head>')) {
        return html.replace('</head>', `<style type="text/css">\n${wordStyles}\n</style>\n</head>`);
      } else if (html.includes('<head>')) {
        return html.replace('<head>', `<head>\n<style type="text/css">\n${wordStyles}\n</style>`);
      } else {
        // åœ¨htmlæ ‡ç­¾åæ·»åŠ head
        return html.replace(
          '<html>',
          `<html>\n<head>\n<style type="text/css">\n${wordStyles}\n</style>\n</head>`
        );
      }
    } else {
      // åˆ›å»ºå®Œæ•´çš„HTMLç»“æ„
      return `<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style type="text/css">
${wordStyles}
  </style>
</head>
<body>
${html}
</body>
</html>`;
    }
  }

  /**
   * ç”ŸæˆWordæ ·å¼CSS
   */
  private generateWordStylesCSS(): string {
    const fontFamily = this.options.customFontFamily || 'Microsoft YaHei';

    return `
/* ===== Wordæ ·å¼ä¿®å¤ - å¼ºåˆ¶åº”ç”¨ ===== */

/* å…¨å±€é‡ç½®å’ŒåŸºç¡€æ ·å¼ */
* {
  box-sizing: border-box !important;
  -webkit-print-color-adjust: exact !important;
  color-adjust: exact !important;
  print-color-adjust: exact !important;
}

/* å­—ä½“å¼ºåˆ¶è®¾ç½® */
html, body, p, div, span, h1, h2, h3, h4, h5, h6, 
table, td, th, tr, ul, ol, li, strong, em, b, i {
  font-family: "Calibri", "${fontFamily}", "SimSun", "å®‹ä½“", sans-serif !important;
  color: #000000 !important;
  background-color: transparent !important;
}

/* æ ¹å…ƒç´ æ ·å¼ */
html, body {
  margin: 0 !important;
  padding: 0 !important;
  background-color: #ffffff !important;
  font-size: 11pt !important;
  line-height: 1.08 !important;
}

/* æ®µè½æ ·å¼ */
p, p.normal, p.docx-paragraph, .normal {
  font-size: 11pt !important;
  line-height: 1.08 !important;
  margin: 0pt 0pt 8pt 0pt !important;
  text-align: left !important;
  color: #000000 !important;
}

/* æ ‡é¢˜æ ·å¼ */
h1, h1.heading-1, h1.title, .heading-1, .title {
  font-family: "Calibri Light", "Calibri", "${fontFamily}", sans-serif !important;
  font-size: 16pt !important;
  font-weight: normal !important;
  color: #2F5496 !important;
  margin: 24pt 0pt 0pt 0pt !important;
  line-height: 1.15 !important;
}

h2, h2.heading-2, h2.subtitle, .heading-2, .subtitle {
  font-family: "Calibri Light", "Calibri", "${fontFamily}", sans-serif !important;
  font-size: 13pt !important;
  font-weight: normal !important;
  color: #2F5496 !important;
  margin: 10pt 0pt 0pt 0pt !important;
  line-height: 1.15 !important;
}

h3, h3.heading-3, .heading-3 {
  font-family: "Calibri Light", "Calibri", "${fontFamily}", sans-serif !important;
  font-size: 12pt !important;
  font-weight: normal !important;
  color: #1F3763 !important;
  margin: 10pt 0pt 0pt 0pt !important;
  line-height: 1.15 !important;
}

h4, h4.heading-4, .heading-4,
h5, h5.heading-5, .heading-5,
h6, h6.heading-6, .heading-6 {
  font-size: 11pt !important;
  font-weight: bold !important;
  color: #2F5496 !important;
  margin: 10pt 0pt 0pt 0pt !important;
  line-height: 1.15 !important;
}

/* æ–‡æœ¬æ ¼å¼ */
strong, strong.word-strong, strong.docx-bold, b {
  font-weight: bold !important;
}

em, em.word-emphasis, em.docx-italic, i {
  font-style: italic !important;
}

span.docx-underline, u {
  text-decoration: underline !important;
}

span.docx-strikethrough, del, strike {
  text-decoration: line-through !important;
}

/* è¡¨æ ¼æ ·å¼ */
table, table.docx-table {
  width: 100% !important;
  border-collapse: collapse !important;
  margin: 0pt 0pt 8pt 0pt !important;
  font-size: 11pt !important;
  line-height: 1.08 !important;
}

td, td.docx-cell, th, th.docx-header {
  border: 0.5pt solid #000000 !important;
  padding: 0pt 5.4pt !important;
  vertical-align: top !important;
  font-size: 11pt !important;
  line-height: 1.08 !important;
}

/* åˆ—è¡¨æ ·å¼ */
ul, ol {
  margin: 0pt 0pt 8pt 0pt !important;
  padding-left: 36pt !important;
}

li, li.list-item, li.bullet-item, li.numbered-item {
  margin: 0pt !important;
  font-size: 11pt !important;
  line-height: 1.08 !important;
}

/* å›¾ç‰‡æ ·å¼ */
img {
  max-width: 100% !important;
  height: auto !important;
  display: inline-block !important;
}

/* é“¾æ¥æ ·å¼ */
a {
  color: #0563C1 !important;
  text-decoration: underline !important;
}

a:visited {
  color: #954F72 !important;
}

/* æ‰“å°æ ·å¼ */
@media print {
  * {
    -webkit-print-color-adjust: exact !important;
    color-adjust: exact !important;
    print-color-adjust: exact !important;
  }
  
  body {
    background-color: white !important;
  }
}

@page {
  size: A4 portrait !important;
  margin: 2.54cm 1.91cm 2.54cm 1.91cm !important;
}
`;
  }

  /**
   * ä¼˜åŒ–æœ€ç»ˆHTML
   */
  private optimizeFinalHtml(html: string): string {
    this.log('ğŸ”§ ä¼˜åŒ–æœ€ç»ˆHTML...');

    // ä½¿ç”¨cheerioå¤„ç†HTML
    const $ = cheerio.load(html, { decodeEntities: false });

    // ç¡®ä¿æœ‰DOCTYPE
    if (!html.includes('<!DOCTYPE')) {
      // cheerioä¼šè‡ªåŠ¨æ·»åŠ htmlç»“æ„ï¼Œä½†æˆ‘ä»¬éœ€è¦ç¡®ä¿DOCTYPE
      const finalHtml = $.html();
      return `<!DOCTYPE html>\n${finalHtml}`;
    }

    // ä¸ºæ²¡æœ‰classçš„å…ƒç´ æ·»åŠ é€‚å½“çš„class
    $('p').each((i, el) => {
      const $el = $(el);
      if (!$el.attr('class')) {
        $el.addClass('docx-paragraph');
      }
    });

    $('span').each((i, el) => {
      const $el = $(el);
      if (!$el.attr('class')) {
        $el.addClass('docx-run');
      }
    });

    $('table').each((i, el) => {
      const $el = $(el);
      if (!$el.attr('class')) {
        $el.addClass('docx-table');
      }
    });

    return $.html();
  }

  /**
   * ç»Ÿè®¡å¸¦æ ·å¼çš„å…ƒç´ æ•°é‡
   */
  private countStyledElements(html: string): number {
    const $ = cheerio.load(html, { decodeEntities: false });
    return $('[class], [style]').length;
  }

  /**
   * æ¸…ç†ç±»å
   */
  private sanitizeClassName(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9\u4e00-\u9fff]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  }

  /**
   * è°ƒè¯•æ—¥å¿—
   */
  private log(...args: any[]): void {
    if (this.options.enableDebug) {
      console.error(...args);
    }
  }
}

/**
 * å¯¼å‡ºä¿®å¤å‡½æ•°
 */
export async function fixDocxToHtmlStyles(
  docxPath: string,
  options: StyleFixOptions = {}
): Promise<FixedConversionResult> {
  const engine = new StyleFixEngine(options);
  return await engine.fixDocxToHtml(docxPath);
}
